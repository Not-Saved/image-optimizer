{"version":3,"sources":["../src/server/constants/constants.ts","../src/server/utils/detectContentType.ts","../src/server/sharp/getSharp.ts","../src/server/sharp/optimizeImage.ts","../src/server/utils/parseCacheControl.ts","../src/server/utils/getMaxAge.ts","../src/server/fetch/fetchExternalImage.ts","../src/server/cache/ImageOptimizerCache.ts","../src/server/utils/getHash.ts","../src/server/utils/getSupportedMimeType.ts","../src/server/utils/hasLocalMatch.ts","../src/server/utils/hasRemoteMatch.ts","../src/server.ts"],"sourcesContent":["export const AVIF = \"image/avif\";\nexport const WEBP = \"image/webp\";\nexport const PNG = \"image/png\";\nexport const JPEG = \"image/jpeg\";\nexport const GIF = \"image/gif\";\nexport const SVG = \"image/svg+xml\";\nexport const ICO = \"image/x-icon\";\nexport const TIFF = \"image/tiff\";\nexport const BMP = \"image/bmp\";\n\nexport const CACHE_VERSION = 4;\nexport const ANIMATABLE_TYPES = [WEBP, PNG, GIF];\nexport const VECTOR_TYPES = [SVG];\nexport const BLUR_IMG_SIZE = 8; // should match `next-image-loader`\nexport const BLUR_QUALITY = 70; // should match `next-image-load\n","import {\n  AVIF,\n  BMP,\n  GIF,\n  ICO,\n  JPEG,\n  PNG,\n  SVG,\n  TIFF,\n  WEBP,\n} from \"../constants/constants\";\n\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nexport function detectContentType(buffer: Buffer) {\n  if ([0xff, 0xd8, 0xff].every((b, i) => buffer[i] === b)) {\n    return JPEG;\n  }\n  if (\n    [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a].every(\n      (b, i) => buffer[i] === b\n    )\n  ) {\n    return PNG;\n  }\n  if ([0x47, 0x49, 0x46, 0x38].every((b, i) => buffer[i] === b)) {\n    return GIF;\n  }\n  if (\n    [0x52, 0x49, 0x46, 0x46, 0, 0, 0, 0, 0x57, 0x45, 0x42, 0x50].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return WEBP;\n  }\n  if ([0x3c, 0x3f, 0x78, 0x6d, 0x6c].every((b, i) => buffer[i] === b)) {\n    return SVG;\n  }\n  if ([0x3c, 0x73, 0x76, 0x67].every((b, i) => buffer[i] === b)) {\n    return SVG;\n  }\n  if (\n    [0, 0, 0, 0, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return AVIF;\n  }\n  if ([0x00, 0x00, 0x01, 0x00].every((b, i) => buffer[i] === b)) {\n    return ICO;\n  }\n  if ([0x49, 0x49, 0x2a, 0x00].every((b, i) => buffer[i] === b)) {\n    return TIFF;\n  }\n  if ([0x42, 0x4d].every((b, i) => buffer[i] === b)) {\n    return BMP;\n  }\n  return null;\n}\n","import sharp from \"sharp\";\n\ntype SharpNamespace = typeof sharp;\ntype Sharp = (\n  input?:\n    | Buffer\n    | ArrayBuffer\n    | Uint8Array\n    | Uint8ClampedArray\n    | Int8Array\n    | Uint16Array\n    | Int16Array\n    | Uint32Array\n    | Int32Array\n    | Float32Array\n    | Float64Array\n    | string,\n  options?: sharp.SharpOptions\n) => sharp.Sharp;\n\nlet _sharp: SharpNamespace;\nexport function getSharp(concurrency?: number | null | undefined): Sharp {\n  if (_sharp) {\n    return _sharp;\n  }\n  try {\n    _sharp = sharp;\n    if (_sharp && sharp.concurrency() > 1) {\n      // Reducing concurrency should reduce the memory usage too.\n      // We more aggressively reduce in dev but also reduce in prod.\n      // https://sharp.pixelplumbing.com/api-utility#concurrency\n      const divisor = process.env.NODE_ENV === \"development\" ? 4 : 2;\n      _sharp.concurrency(\n        concurrency ?? Math.floor(Math.max(_sharp.concurrency() / divisor, 1))\n      );\n    }\n  } catch (e: unknown) {\n    throw e;\n  }\n  return _sharp;\n}\n","import { AVIF, JPEG, PNG, WEBP } from \"../constants/constants\";\nimport { getSharp } from \"./getSharp\";\n\nexport async function optimizeImage({\n  buffer,\n  contentType,\n  quality,\n  width,\n  height,\n  limitInputPixels,\n  sequentialRead,\n  timeoutInSeconds,\n}: {\n  buffer: Buffer;\n  contentType: string;\n  quality: number;\n  width: number;\n  height?: number;\n  limitInputPixels?: number;\n  sequentialRead?: boolean | null;\n  timeoutInSeconds?: number;\n}): Promise<Buffer> {\n  const _sharp = getSharp();\n\n  const transformer = _sharp(buffer, {\n    limitInputPixels,\n    sequentialRead: sequentialRead ?? undefined,\n  })\n    .timeout({\n      seconds: timeoutInSeconds ?? 7,\n    })\n    .rotate();\n\n  if (height) {\n    transformer.resize(width, height);\n  } else {\n    transformer.resize(width, undefined, {\n      withoutEnlargement: true,\n    });\n  }\n\n  if (contentType === AVIF) {\n    transformer.avif({\n      quality: Math.max(quality - 20, 1),\n      effort: 3,\n    });\n  } else if (contentType === WEBP) {\n    transformer.webp({ quality });\n  } else if (contentType === PNG) {\n    transformer.png({ quality });\n  } else if (contentType === JPEG) {\n    transformer.jpeg({ quality, mozjpeg: true });\n  }\n\n  const optimizedBuffer = await transformer.toBuffer();\n\n  return optimizedBuffer;\n}\n","export function parseCacheControl(\n  str: string | null | undefined\n): Map<string, string> {\n  const map = new Map<string, string>();\n  if (!str) {\n    return map;\n  }\n  for (let directive of str.split(\",\")) {\n    let [key, value] = directive.trim().split(\"=\", 2);\n    key = key.toLowerCase();\n    if (value) {\n      value = value.toLowerCase();\n    }\n    map.set(key, value);\n  }\n  return map;\n}\n","import { parseCacheControl } from \"./parseCacheControl\";\n\nexport function getMaxAge(str: string | null | undefined): number {\n  const map = parseCacheControl(str);\n  if (map) {\n    let age = map.get(\"s-maxage\") || map.get(\"max-age\") || \"\";\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1);\n    }\n    const n = parseInt(age, 10);\n    if (!isNaN(n)) {\n      return n;\n    }\n  }\n  return 0;\n}\n","import { ImageUpstream } from \"../types\";\n\nexport async function fetchExternalImage(href: string): Promise<ImageUpstream> {\n  const res = await fetch(href, {\n    signal: AbortSignal.timeout(7_000),\n  }).catch((err) => err as Error);\n\n  if (res instanceof Error) {\n    const err = res as Error;\n    if (err.name === \"TimeoutError\") {\n      throw new Error(\n        '\"url\" parameter is valid but upstream response timed out'\n      );\n    }\n    throw err;\n  }\n\n  if (!res.ok) {\n    throw new Error(\n      '\"url\" parameter is valid but upstream response is invalid'\n    );\n  }\n\n  const buffer = Buffer.from(await res.arrayBuffer());\n  const contentType = res.headers.get(\"Content-Type\");\n  const cacheControl = res.headers.get(\"Cache-Control\");\n  return { buffer, contentType, cacheControl };\n}\n","import { join } from \"node:path\";\nimport { BLUR_IMG_SIZE, CACHE_VERSION } from \"../constants/constants\";\nimport { getHash } from \"../utils/getHash\";\nimport { getSupportedMimeType } from \"../utils/getSupportedMimeType\";\nimport { promises } from \"node:fs\";\nimport { hasLocalMatch } from \"../utils/hasLocalMatch\";\nimport { hasRemoteMatch } from \"../utils/hasRemoteMatch\";\nimport { ImageConfigComplete } from \"../..\";\n\nexport class ImageOptimizerCache {\n  private cacheDir: string;\n  private promisesCache: Map<string, Promise<IncrementalCacheValue | null>> =\n    new Map();\n\n  static getCacheKey({\n    href,\n    width,\n    quality,\n    mimeType,\n  }: {\n    href: string;\n    width: number;\n    quality: number;\n    mimeType: string;\n  }): string {\n    return getHash([CACHE_VERSION, href, width, quality, mimeType]);\n  }\n\n  constructor({ distDir }: { distDir: string }) {\n    this.cacheDir = join(distDir, \"cache\", \"images\");\n  }\n\n  async get(cacheKey: string): Promise<IncrementalCacheEntry | null> {\n    try {\n      const cacheDir = join(this.cacheDir, cacheKey);\n      const files = await promises.readdir(cacheDir);\n      const now = Date.now();\n\n      for (const file of files) {\n        const [maxAgeSt, expireAtSt, /* etag, upstreamEtag, */ extension] =\n          file.split(\".\", 5);\n        const buffer = await promises.readFile(join(cacheDir, file));\n        const expireAt = Number(expireAtSt);\n        const maxAge = Number(maxAgeSt);\n\n        return {\n          value: {\n            // etag,\n            buffer,\n            extension,\n            maxAge: maxAge,\n            //  upstreamEtag,\n          },\n          expireAt,\n          isStale: now > expireAt,\n        };\n      }\n    } catch (_) {\n      // failed to read from cache dir, treat as cache miss\n    }\n    return null;\n  }\n  async set(\n    cacheKey: string,\n    value: IncrementalCacheValue\n  ): Promise<IncrementalCacheEntry> {\n    if (typeof value.maxAge !== \"number\") {\n      throw new Error(\"invariant revalidate must be a number for image-cache\");\n    }\n    const expireAt = Math.max(value.maxAge) * 1000 + Date.now();\n\n    if (this.promisesCache.has(cacheKey)) {\n      const incrementalCacheValuePromise = this.promisesCache.get(cacheKey);\n\n      const incrementalCacheValue =\n        (await incrementalCacheValuePromise) as IncrementalCacheValue;\n      return {\n        value: incrementalCacheValue,\n        expireAt,\n        isStale: false,\n      };\n    }\n    const incrementalCacheValuePromise = writeToCacheDir(\n      join(this.cacheDir, cacheKey),\n      value.extension,\n      value.maxAge,\n      expireAt,\n      value.buffer\n      /* value.etag,\n        value.upstreamEtag */\n    );\n    this.promisesCache.set(cacheKey, incrementalCacheValuePromise);\n    const incrementalCacheValue = await incrementalCacheValuePromise;\n    this.promisesCache.delete(cacheKey);\n    return {\n      value: incrementalCacheValue,\n      expireAt,\n      isStale: false,\n    };\n  }\n}\n\nasync function writeToCacheDir(\n  dir: string,\n  extension: string,\n  maxAge: number,\n  expireAt: number,\n  buffer: Buffer\n  /*  etag: string,\n  upstreamEtag: string */\n): Promise<IncrementalCacheValue> {\n  /* const filename = join(\n    dir,\n    `${maxAge}.${expireAt}.${etag}.${upstreamEtag}.${extension}`\n  ); */\n\n  const filename = join(dir, `${maxAge}.${expireAt}.${extension}`);\n\n  await promises.rm(dir, { recursive: true, force: true }).catch(() => {});\n\n  await promises.mkdir(dir, { recursive: true });\n  await promises.writeFile(filename, buffer);\n  return { buffer, extension, maxAge };\n}\n\nexport type IncrementalCacheEntry = {\n  value: IncrementalCacheValue;\n  expireAt: number;\n  isStale: boolean;\n};\n\nexport type IncrementalCacheValue = {\n  extension: string;\n  buffer: Buffer;\n  //etag: string;\n  //upstreamEtag: string;\n  maxAge: number;\n};\n\nexport function validateParams(\n  acceptHeader: string,\n  query: {\n    url: string;\n    w: string;\n    q: string;\n  },\n  config: ImageConfigComplete,\n  isDev?: boolean\n):\n  | {\n      quality: number;\n      width: number;\n      mimeType: string;\n      href: string;\n      sizes: number[];\n      isAbsolute: boolean;\n      isStatic: boolean;\n    }\n  | { errorMessage: string } {\n  const {\n    deviceSizes = [],\n    imageSizes = [],\n    remotePatterns,\n    localPatterns,\n    formats = [\"image/webp\"],\n  } = config;\n\n  const { url, w, q } = query;\n  let href: string;\n\n  if (!url) {\n    return { errorMessage: '\"url\" parameter is required' };\n  } else if (Array.isArray(url)) {\n    return { errorMessage: '\"url\" parameter cannot be an array' };\n  }\n\n  if (url.length > 3072) {\n    return { errorMessage: '\"url\" parameter is too long' };\n  }\n\n  if (url.startsWith(\"//\")) {\n    return {\n      errorMessage: '\"url\" parameter cannot be a protocol-relative URL (//)',\n    };\n  }\n\n  let isAbsolute: boolean;\n\n  if (url.startsWith(\"/\")) {\n    href = url;\n    isAbsolute = false;\n    /* if (\n        /\\/_next\\/image($|\\/)/.test(\n          decodeURIComponent(parseUrl(url)?.pathname ?? \"\")\n        )\n      ) {\n        return {\n          errorMessage: '\"url\" parameter cannot be recursive',\n        };\n      } */\n    if (!hasLocalMatch(localPatterns, url)) {\n      return { errorMessage: '\"url\" parameter is not allowed' };\n    }\n  } else {\n    let hrefParsed: URL;\n\n    try {\n      hrefParsed = new URL(url);\n      href = hrefParsed.toString();\n      isAbsolute = true;\n    } catch (_error) {\n      return { errorMessage: '\"url\" parameter is invalid' };\n    }\n\n    if (![\"http:\", \"https:\"].includes(hrefParsed.protocol)) {\n      return { errorMessage: '\"url\" parameter is invalid' };\n    }\n\n    if (!hasRemoteMatch(remotePatterns, hrefParsed)) {\n      return { errorMessage: '\"url\" parameter is not allowed' };\n    }\n  }\n\n  if (!w) {\n    return { errorMessage: '\"w\" parameter (width) is required' };\n  } else if (Array.isArray(w)) {\n    return { errorMessage: '\"w\" parameter (width) cannot be an array' };\n  } else if (!/^[0-9]+$/.test(w)) {\n    return {\n      errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n    };\n  }\n\n  if (!q) {\n    return { errorMessage: '\"q\" parameter (quality) is required' };\n  } else if (Array.isArray(q)) {\n    return { errorMessage: '\"q\" parameter (quality) cannot be an array' };\n  } else if (!/^[0-9]+$/.test(q)) {\n    return {\n      errorMessage:\n        '\"q\" parameter (quality) must be an integer between 1 and 100',\n    };\n  }\n\n  const width = parseInt(w, 10);\n\n  if (width <= 0 || isNaN(width)) {\n    return {\n      errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n    };\n  }\n\n  const sizes: number[] = [...(deviceSizes || []), ...(imageSizes || [])];\n\n  const isValidSize =\n    sizes.includes(width) || (isDev && width <= BLUR_IMG_SIZE);\n\n  if (!isValidSize) {\n    return {\n      errorMessage: `\"w\" parameter (width) of ${width} is not allowed`,\n    };\n  }\n\n  const quality = parseInt(q, 10);\n\n  if (isNaN(quality) || quality < 1 || quality > 100) {\n    return {\n      errorMessage:\n        '\"q\" parameter (quality) must be an integer between 1 and 100',\n    };\n  }\n\n  const mimeType = getSupportedMimeType(formats || [], acceptHeader);\n\n  const isStatic = false;\n\n  return {\n    href,\n    sizes,\n    isAbsolute,\n    isStatic,\n    width,\n    quality,\n    mimeType,\n  };\n}\n","import { createHash } from \"node:crypto\";\n\nexport function getHash(items: (string | number | Buffer)[]) {\n    const hash = createHash(\"sha256\");\n    for (let item of items) {\n      if (typeof item === \"number\") hash.update(String(item));\n      else {\n        hash.update(item);\n      }\n    }\n    // See https://en.wikipedia.org/wiki/Base64#URL_applications\n    return hash.digest(\"base64url\");\n  }","export function getSupportedMimeType(options: string[], accept = \"\"): string {\n    const mimeType = /* mediaType(accept, options) */ \"image/webp\";\n    return accept.includes(mimeType) ? mimeType : \"\";\n  }\n  ","import { LocalPattern } from \"../..\";\n\nexport function matchLocalPattern(pattern: LocalPattern, url: URL): boolean {\n  if (pattern.search !== undefined) {\n    if (pattern.search !== url.search) {\n      return false;\n    }\n  }\n\n  /* if (!makeRe(pattern.pathname ?? \"**\", { dot: true }).test(url.pathname)) {\n    return false;\n  } */\n\n  /* Simply matching for now */\n  if (pattern.pathname !== url.pathname) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function hasLocalMatch(\n  localPatterns: LocalPattern[] | undefined,\n  urlPathAndQuery: string\n): boolean {\n  if (!localPatterns) {\n    // if the user didn't define \"localPatterns\", we allow all local images\n    return true;\n  }\n  const url = new URL(urlPathAndQuery, \"http://n\");\n  return localPatterns.some((p) => matchLocalPattern(p, url));\n}\n","import { RemotePattern } from \"../..\";\n\n// Modifying this function should also modify writeImagesManifest()\nexport function matchRemotePattern(pattern: RemotePattern, url: URL): boolean {\n  if (pattern.protocol !== undefined) {\n    const actualProto = url.protocol.slice(0, -1);\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\n      `Pattern should define hostname but found\\n${JSON.stringify(pattern)}`\n    );\n  } else {\n    if (pattern.hostname !== url.hostname) {\n      return false;\n    }\n  }\n\n  if (pattern.search !== undefined) {\n    if (pattern.search !== url.search) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname !== url.hostname) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function hasRemoteMatch(\n  remotePatterns: RemotePattern[],\n  url: URL\n): boolean {\n  return remotePatterns.some((p) => matchRemotePattern(p, url));\n}\n","import { detectContentType } from \"./server/utils/detectContentType\";\nimport { optimizeImage } from \"./server/sharp/optimizeImage\";\nimport { JPEG } from \"./server/constants/constants\";\nimport { getMaxAge } from \"./server/utils/getMaxAge\";\nimport { ImageUpstream } from \"./server/types\";\n\nexport * from \"./server/fetch/fetchExternalImage\";\nexport * from \"./server/types\";\nexport * from \"./server/cache/ImageOptimizerCache\";\n\nexport async function imageOptimizer(\n  imageUpstream: ImageUpstream,\n  params: {\n    quality: number;\n    width: number;\n    mimeType: string;\n  }\n): Promise<{\n  buffer: Buffer;\n  contentType: string;\n  extension: string;\n  maxAge: number;\n  error?: unknown;\n}> {\n  const { quality, width, mimeType } = params;\n  const { buffer: upstreamBuffer } = imageUpstream;\n  const maxAge = getMaxAge(imageUpstream.cacheControl);\n\n  const upstreamType =\n    imageUpstream.contentType?.toLowerCase().trim() ||\n    detectContentType(upstreamBuffer);\n\n  if (upstreamType) {\n    if (upstreamType.startsWith(\"image/svg\")) {\n      throw new Error(\n        '\"url\" parameter is valid but image type svg is not allowed'\n      );\n    }\n    /*    if (ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)) {\n      if (!opts.silent) {\n        Log.warnOnce(\n          `The requested resource \"${href}\" is an animated image so it will not be optimized. Consider adding the \"unoptimized\" property to the <Image>.`\n        );\n      }\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge,\n        etag: upstreamEtag,\n        upstreamEtag,\n      };\n    } */\n\n    /* if (VECTOR_TYPES.includes(upstreamType)) {\n      // We don't warn here because we already know that \"dangerouslyAllowSVG\"\n      // was enabled above, therefore the user explicitly opted in.\n      // If we add more VECTOR_TYPES besides SVG, perhaps we could warn for those.\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge,\n      };\n    } */\n\n    if (!upstreamType.startsWith(\"image/\") || upstreamType.includes(\",\")) {\n      throw new Error(\"The requested resource isn't a valid image.\");\n    }\n  }\n\n  let contentType: string;\n\n  if (mimeType) {\n    contentType = mimeType;\n  } else {\n    contentType = JPEG;\n  }\n\n  /*  const previouslyCachedImage = getPreviouslyCachedImageOrNull(\n    imageUpstream,\n    opts.previousCacheEntry\n  );\n  if (previouslyCachedImage) {\n    return {\n      buffer: previouslyCachedImage.buffer,\n      contentType,\n      maxAge: opts?.previousCacheEntry?.curRevalidate || maxAge,\n      etag: previouslyCachedImage.etag,\n      upstreamEtag: previouslyCachedImage.upstreamEtag,\n    };\n  }\n */\n  try {\n    let optimizedBuffer = await optimizeImage({\n      buffer: upstreamBuffer,\n      contentType,\n      quality,\n      width,\n    });\n    /* if (opts.isDev && width <= BLUR_IMG_SIZE && quality === BLUR_QUALITY) {\n      // During `next dev`, we don't want to generate blur placeholders with webpack\n      // because it can delay starting the dev server. Instead, `next-image-loader.js`\n      // will inline a special url to lazily generate the blur placeholder at request time.\n      const meta = await getImageSize(optimizedBuffer);\n      const blurOpts = {\n        blurWidth: meta.width,\n        blurHeight: meta.height,\n        blurDataURL: `data:${contentType};base64,${optimizedBuffer.toString(\n          \"base64\"\n        )}`,\n      };\n      optimizedBuffer = Buffer.from(unescape(getImageBlurSvg(blurOpts)));\n      contentType = \"image/svg+xml\";\n    } */\n    return {\n      buffer: optimizedBuffer,\n      contentType,\n      extension: contentType.replace(\"image/\", \"\"),\n      maxAge: Math.max(maxAge, 60),\n    };\n  } catch (error) {\n    if (upstreamType) {\n      // If we fail to optimize, fallback to the original image\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        extension: contentType.replace(\"image/\", \"\"),\n        maxAge: 60,\n        error,\n      };\n    } else {\n      throw new Error(\n        \"Unable to optimize image and unable to fallback to upstream image\"\n      );\n    }\n  }\n}\n"],"mappings":";AAAO,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,MAAM;AACZ,IAAM,OAAO;AACb,IAAM,MAAM;AACZ,IAAM,MAAM;AACZ,IAAM,MAAM;AACZ,IAAM,OAAO;AACb,IAAM,MAAM;AAEZ,IAAM,gBAAgB;AAGtB,IAAM,gBAAgB;;;ACItB,SAAS,kBAAkB,QAAgB;AAChD,MAAI,CAAC,KAAM,KAAM,GAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AACvD,WAAO;AAAA,EACT;AACA,MACE,CAAC,KAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,EAAI,EAAE;AAAA,IAC/C,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM;AAAA,EAC1B,GACA;AACA,WAAO;AAAA,EACT;AACA,MAAI,CAAC,IAAM,IAAM,IAAM,EAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AAC7D,WAAO;AAAA,EACT;AACA,MACE,CAAC,IAAM,IAAM,IAAM,IAAM,GAAG,GAAG,GAAG,GAAG,IAAM,IAAM,IAAM,EAAI,EAAE;AAAA,IAC3D,CAAC,GAAG,MAAM,CAAC,KAAK,OAAO,CAAC,MAAM;AAAA,EAChC,GACA;AACA,WAAO;AAAA,EACT;AACA,MAAI,CAAC,IAAM,IAAM,KAAM,KAAM,GAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AACnE,WAAO;AAAA,EACT;AACA,MAAI,CAAC,IAAM,KAAM,KAAM,GAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AAC7D,WAAO;AAAA,EACT;AACA,MACE,CAAC,GAAG,GAAG,GAAG,GAAG,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,GAAI,EAAE;AAAA,IAC3D,CAAC,GAAG,MAAM,CAAC,KAAK,OAAO,CAAC,MAAM;AAAA,EAChC,GACA;AACA,WAAO;AAAA,EACT;AACA,MAAI,CAAC,GAAM,GAAM,GAAM,CAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AAC7D,WAAO;AAAA,EACT;AACA,MAAI,CAAC,IAAM,IAAM,IAAM,CAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AAC7D,WAAO;AAAA,EACT;AACA,MAAI,CAAC,IAAM,EAAI,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,GAAG;AACjD,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;AC7DA,OAAO,WAAW;AAoBlB,IAAI;AACG,SAAS,SAAS,aAAgD;AACvE,MAAI,QAAQ;AACV,WAAO;AAAA,EACT;AACA,MAAI;AACF,aAAS;AACT,QAAI,UAAU,MAAM,YAAY,IAAI,GAAG;AAIrC,YAAM,UAAU,QAAQ,IAAI,aAAa,gBAAgB,IAAI;AAC7D,aAAO;AAAA,QACL,eAAe,KAAK,MAAM,KAAK,IAAI,OAAO,YAAY,IAAI,SAAS,CAAC,CAAC;AAAA,MACvE;AAAA,IACF;AAAA,EACF,SAAS,GAAY;AACnB,UAAM;AAAA,EACR;AACA,SAAO;AACT;;;ACrCA,eAAsB,cAAc;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GASoB;AAClB,QAAMA,UAAS,SAAS;AAExB,QAAM,cAAcA,QAAO,QAAQ;AAAA,IACjC;AAAA,IACA,gBAAgB,kBAAkB;AAAA,EACpC,CAAC,EACE,QAAQ;AAAA,IACP,SAAS,oBAAoB;AAAA,EAC/B,CAAC,EACA,OAAO;AAEV,MAAI,QAAQ;AACV,gBAAY,OAAO,OAAO,MAAM;AAAA,EAClC,OAAO;AACL,gBAAY,OAAO,OAAO,QAAW;AAAA,MACnC,oBAAoB;AAAA,IACtB,CAAC;AAAA,EACH;AAEA,MAAI,gBAAgB,MAAM;AACxB,gBAAY,KAAK;AAAA,MACf,SAAS,KAAK,IAAI,UAAU,IAAI,CAAC;AAAA,MACjC,QAAQ;AAAA,IACV,CAAC;AAAA,EACH,WAAW,gBAAgB,MAAM;AAC/B,gBAAY,KAAK,EAAE,QAAQ,CAAC;AAAA,EAC9B,WAAW,gBAAgB,KAAK;AAC9B,gBAAY,IAAI,EAAE,QAAQ,CAAC;AAAA,EAC7B,WAAW,gBAAgB,MAAM;AAC/B,gBAAY,KAAK,EAAE,SAAS,SAAS,KAAK,CAAC;AAAA,EAC7C;AAEA,QAAM,kBAAkB,MAAM,YAAY,SAAS;AAEnD,SAAO;AACT;;;ACzDO,SAAS,kBACd,KACqB;AACrB,QAAM,MAAM,oBAAI,IAAoB;AACpC,MAAI,CAAC,KAAK;AACR,WAAO;AAAA,EACT;AACA,WAAS,aAAa,IAAI,MAAM,GAAG,GAAG;AACpC,QAAI,CAAC,KAAK,KAAK,IAAI,UAAU,KAAK,EAAE,MAAM,KAAK,CAAC;AAChD,UAAM,IAAI,YAAY;AACtB,QAAI,OAAO;AACT,cAAQ,MAAM,YAAY;AAAA,IAC5B;AACA,QAAI,IAAI,KAAK,KAAK;AAAA,EACpB;AACA,SAAO;AACT;;;ACdO,SAAS,UAAU,KAAwC;AAChE,QAAM,MAAM,kBAAkB,GAAG;AACjC,MAAI,KAAK;AACP,QAAI,MAAM,IAAI,IAAI,UAAU,KAAK,IAAI,IAAI,SAAS,KAAK;AACvD,QAAI,IAAI,WAAW,GAAG,KAAK,IAAI,SAAS,GAAG,GAAG;AAC5C,YAAM,IAAI,MAAM,GAAG,EAAE;AAAA,IACvB;AACA,UAAM,IAAI,SAAS,KAAK,EAAE;AAC1B,QAAI,CAAC,MAAM,CAAC,GAAG;AACb,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;ACbA,eAAsB,mBAAmB,MAAsC;AAC7E,QAAM,MAAM,MAAM,MAAM,MAAM;AAAA,IAC5B,QAAQ,YAAY,QAAQ,GAAK;AAAA,EACnC,CAAC,EAAE,MAAM,CAAC,QAAQ,GAAY;AAE9B,MAAI,eAAe,OAAO;AACxB,UAAM,MAAM;AACZ,QAAI,IAAI,SAAS,gBAAgB;AAC/B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,UAAM;AAAA,EACR;AAEA,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,OAAO,KAAK,MAAM,IAAI,YAAY,CAAC;AAClD,QAAM,cAAc,IAAI,QAAQ,IAAI,cAAc;AAClD,QAAM,eAAe,IAAI,QAAQ,IAAI,eAAe;AACpD,SAAO,EAAE,QAAQ,aAAa,aAAa;AAC7C;;;AC3BA,SAAS,YAAY;;;ACArB,SAAS,kBAAkB;AAEpB,SAAS,QAAQ,OAAqC;AACzD,QAAM,OAAO,WAAW,QAAQ;AAChC,WAAS,QAAQ,OAAO;AACtB,QAAI,OAAO,SAAS,SAAU,MAAK,OAAO,OAAO,IAAI,CAAC;AAAA,SACjD;AACH,WAAK,OAAO,IAAI;AAAA,IAClB;AAAA,EACF;AAEA,SAAO,KAAK,OAAO,WAAW;AAChC;;;ACZK,SAAS,qBAAqB,SAAmB,SAAS,IAAY;AACzE,QAAM;AAAA;AAAA,IAA4C;AAAA;AAClD,SAAO,OAAO,SAAS,QAAQ,IAAI,WAAW;AAChD;;;AFCF,SAAS,gBAAgB;;;AGFlB,SAAS,kBAAkB,SAAuB,KAAmB;AAC1E,MAAI,QAAQ,WAAW,QAAW;AAChC,QAAI,QAAQ,WAAW,IAAI,QAAQ;AACjC,aAAO;AAAA,IACT;AAAA,EACF;AAOA,MAAI,QAAQ,aAAa,IAAI,UAAU;AACrC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,SAAS,cACd,eACA,iBACS;AACT,MAAI,CAAC,eAAe;AAElB,WAAO;AAAA,EACT;AACA,QAAM,MAAM,IAAI,IAAI,iBAAiB,UAAU;AAC/C,SAAO,cAAc,KAAK,CAAC,MAAM,kBAAkB,GAAG,GAAG,CAAC;AAC5D;;;AC5BO,SAAS,mBAAmB,SAAwB,KAAmB;AAC5E,MAAI,QAAQ,aAAa,QAAW;AAClC,UAAM,cAAc,IAAI,SAAS,MAAM,GAAG,EAAE;AAC5C,QAAI,QAAQ,aAAa,aAAa;AACpC,aAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,QAAQ,SAAS,QAAW;AAC9B,QAAI,QAAQ,SAAS,IAAI,MAAM;AAC7B,aAAO;AAAA,IACT;AAAA,EACF;AAEA,MAAI,QAAQ,aAAa,QAAW;AAClC,UAAM,IAAI;AAAA,MACR;AAAA,EAA6C,KAAK,UAAU,OAAO,CAAC;AAAA,IACtE;AAAA,EACF,OAAO;AACL,QAAI,QAAQ,aAAa,IAAI,UAAU;AACrC,aAAO;AAAA,IACT;AAAA,EACF;AAEA,MAAI,QAAQ,WAAW,QAAW;AAChC,QAAI,QAAQ,WAAW,IAAI,QAAQ;AACjC,aAAO;AAAA,IACT;AAAA,EACF;AAEA,MAAI,QAAQ,aAAa,IAAI,UAAU;AACrC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,SAAS,eACd,gBACA,KACS;AACT,SAAO,eAAe,KAAK,CAAC,MAAM,mBAAmB,GAAG,GAAG,CAAC;AAC9D;;;AJnCO,IAAM,sBAAN,MAA0B;AAAA,EAmB/B,YAAY,EAAE,QAAQ,GAAwB;AAjB9C,SAAQ,gBACN,oBAAI,IAAI;AAiBR,SAAK,WAAW,KAAK,SAAS,SAAS,QAAQ;AAAA,EACjD;AAAA,EAhBA,OAAO,YAAY;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKW;AACT,WAAO,QAAQ,CAAC,eAAe,MAAM,OAAO,SAAS,QAAQ,CAAC;AAAA,EAChE;AAAA,EAMA,MAAM,IAAI,UAAyD;AACjE,QAAI;AACF,YAAM,WAAW,KAAK,KAAK,UAAU,QAAQ;AAC7C,YAAM,QAAQ,MAAM,SAAS,QAAQ,QAAQ;AAC7C,YAAM,MAAM,KAAK,IAAI;AAErB,iBAAW,QAAQ,OAAO;AACxB,cAAM;AAAA,UAAC;AAAA,UAAU;AAAA;AAAA,UAAsC;AAAA,QAAS,IAC9D,KAAK,MAAM,KAAK,CAAC;AACnB,cAAM,SAAS,MAAM,SAAS,SAAS,KAAK,UAAU,IAAI,CAAC;AAC3D,cAAM,WAAW,OAAO,UAAU;AAClC,cAAM,SAAS,OAAO,QAAQ;AAE9B,eAAO;AAAA,UACL,OAAO;AAAA;AAAA,YAEL;AAAA,YACA;AAAA,YACA;AAAA;AAAA,UAEF;AAAA,UACA;AAAA,UACA,SAAS,MAAM;AAAA,QACjB;AAAA,MACF;AAAA,IACF,SAAS,GAAG;AAAA,IAEZ;AACA,WAAO;AAAA,EACT;AAAA,EACA,MAAM,IACJ,UACA,OACgC;AAChC,QAAI,OAAO,MAAM,WAAW,UAAU;AACpC,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AACA,UAAM,WAAW,KAAK,IAAI,MAAM,MAAM,IAAI,MAAO,KAAK,IAAI;AAE1D,QAAI,KAAK,cAAc,IAAI,QAAQ,GAAG;AACpC,YAAMC,gCAA+B,KAAK,cAAc,IAAI,QAAQ;AAEpE,YAAMC,yBACH,MAAMD;AACT,aAAO;AAAA,QACL,OAAOC;AAAA,QACP;AAAA,QACA,SAAS;AAAA,MACX;AAAA,IACF;AACA,UAAM,+BAA+B;AAAA,MACnC,KAAK,KAAK,UAAU,QAAQ;AAAA,MAC5B,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,MAAM;AAAA;AAAA;AAAA,IAGR;AACA,SAAK,cAAc,IAAI,UAAU,4BAA4B;AAC7D,UAAM,wBAAwB,MAAM;AACpC,SAAK,cAAc,OAAO,QAAQ;AAClC,WAAO;AAAA,MACL,OAAO;AAAA,MACP;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF;AACF;AAEA,eAAe,gBACb,KACA,WACA,QACA,UACA,QAGgC;AAMhC,QAAM,WAAW,KAAK,KAAK,GAAG,MAAM,IAAI,QAAQ,IAAI,SAAS,EAAE;AAE/D,QAAM,SAAS,GAAG,KAAK,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,EAAC,CAAC;AAEvE,QAAM,SAAS,MAAM,KAAK,EAAE,WAAW,KAAK,CAAC;AAC7C,QAAM,SAAS,UAAU,UAAU,MAAM;AACzC,SAAO,EAAE,QAAQ,WAAW,OAAO;AACrC;AAgBO,SAAS,eACd,cACA,OAKA,QACA,OAW2B;AAC3B,QAAM;AAAA,IACJ,cAAc,CAAC;AAAA,IACf,aAAa,CAAC;AAAA,IACd;AAAA,IACA;AAAA,IACA,UAAU,CAAC,YAAY;AAAA,EACzB,IAAI;AAEJ,QAAM,EAAE,KAAK,GAAG,EAAE,IAAI;AACtB,MAAI;AAEJ,MAAI,CAAC,KAAK;AACR,WAAO,EAAE,cAAc,8BAA8B;AAAA,EACvD,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,WAAO,EAAE,cAAc,qCAAqC;AAAA,EAC9D;AAEA,MAAI,IAAI,SAAS,MAAM;AACrB,WAAO,EAAE,cAAc,8BAA8B;AAAA,EACvD;AAEA,MAAI,IAAI,WAAW,IAAI,GAAG;AACxB,WAAO;AAAA,MACL,cAAc;AAAA,IAChB;AAAA,EACF;AAEA,MAAI;AAEJ,MAAI,IAAI,WAAW,GAAG,GAAG;AACvB,WAAO;AACP,iBAAa;AAUb,QAAI,CAAC,cAAc,eAAe,GAAG,GAAG;AACtC,aAAO,EAAE,cAAc,iCAAiC;AAAA,IAC1D;AAAA,EACF,OAAO;AACL,QAAI;AAEJ,QAAI;AACF,mBAAa,IAAI,IAAI,GAAG;AACxB,aAAO,WAAW,SAAS;AAC3B,mBAAa;AAAA,IACf,SAAS,QAAQ;AACf,aAAO,EAAE,cAAc,6BAA6B;AAAA,IACtD;AAEA,QAAI,CAAC,CAAC,SAAS,QAAQ,EAAE,SAAS,WAAW,QAAQ,GAAG;AACtD,aAAO,EAAE,cAAc,6BAA6B;AAAA,IACtD;AAEA,QAAI,CAAC,eAAe,gBAAgB,UAAU,GAAG;AAC/C,aAAO,EAAE,cAAc,iCAAiC;AAAA,IAC1D;AAAA,EACF;AAEA,MAAI,CAAC,GAAG;AACN,WAAO,EAAE,cAAc,oCAAoC;AAAA,EAC7D,WAAW,MAAM,QAAQ,CAAC,GAAG;AAC3B,WAAO,EAAE,cAAc,2CAA2C;AAAA,EACpE,WAAW,CAAC,WAAW,KAAK,CAAC,GAAG;AAC9B,WAAO;AAAA,MACL,cAAc;AAAA,IAChB;AAAA,EACF;AAEA,MAAI,CAAC,GAAG;AACN,WAAO,EAAE,cAAc,sCAAsC;AAAA,EAC/D,WAAW,MAAM,QAAQ,CAAC,GAAG;AAC3B,WAAO,EAAE,cAAc,6CAA6C;AAAA,EACtE,WAAW,CAAC,WAAW,KAAK,CAAC,GAAG;AAC9B,WAAO;AAAA,MACL,cACE;AAAA,IACJ;AAAA,EACF;AAEA,QAAM,QAAQ,SAAS,GAAG,EAAE;AAE5B,MAAI,SAAS,KAAK,MAAM,KAAK,GAAG;AAC9B,WAAO;AAAA,MACL,cAAc;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,QAAkB,CAAC,GAAI,eAAe,CAAC,GAAI,GAAI,cAAc,CAAC,CAAE;AAEtE,QAAM,cACJ,MAAM,SAAS,KAAK,KAAM,SAAS,SAAS;AAE9C,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,MACL,cAAc,4BAA4B,KAAK;AAAA,IACjD;AAAA,EACF;AAEA,QAAM,UAAU,SAAS,GAAG,EAAE;AAE9B,MAAI,MAAM,OAAO,KAAK,UAAU,KAAK,UAAU,KAAK;AAClD,WAAO;AAAA,MACL,cACE;AAAA,IACJ;AAAA,EACF;AAEA,QAAM,WAAW,qBAAqB,WAAW,CAAC,GAAG,YAAY;AAEjE,QAAM,WAAW;AAEjB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AKnRA,eAAsB,eACpB,eACA,QAWC;AACD,QAAM,EAAE,SAAS,OAAO,SAAS,IAAI;AACrC,QAAM,EAAE,QAAQ,eAAe,IAAI;AACnC,QAAM,SAAS,UAAU,cAAc,YAAY;AAEnD,QAAM,eACJ,cAAc,aAAa,YAAY,EAAE,KAAK,KAC9C,kBAAkB,cAAc;AAElC,MAAI,cAAc;AAChB,QAAI,aAAa,WAAW,WAAW,GAAG;AACxC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AA2BA,QAAI,CAAC,aAAa,WAAW,QAAQ,KAAK,aAAa,SAAS,GAAG,GAAG;AACpE,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAAA,EACF;AAEA,MAAI;AAEJ,MAAI,UAAU;AACZ,kBAAc;AAAA,EAChB,OAAO;AACL,kBAAc;AAAA,EAChB;AAgBA,MAAI;AACF,QAAI,kBAAkB,MAAM,cAAc;AAAA,MACxC,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAgBD,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,MACA,WAAW,YAAY,QAAQ,UAAU,EAAE;AAAA,MAC3C,QAAQ,KAAK,IAAI,QAAQ,EAAE;AAAA,IAC7B;AAAA,EACF,SAAS,OAAO;AACd,QAAI,cAAc;AAEhB,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,WAAW,YAAY,QAAQ,UAAU,EAAE;AAAA,QAC3C,QAAQ;AAAA,QACR;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;","names":["_sharp","incrementalCacheValuePromise","incrementalCacheValue"]}