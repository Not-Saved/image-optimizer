{"version":3,"sources":["../src/index.ts","../src/constants/index.ts","../src/utils/detectContentType.ts","../src/sharp/getSharp.ts","../src/sharp/optimizeImage.ts","../src/utils/parseCacheControl.ts","../src/utils/getMaxAge.ts","../src/fetch/fetchExternalImage.ts","../src/cache/index.ts","../src/utils/getHash.ts","../src/utils/getSupportedMimeType.ts"],"sourcesContent":["import { detectContentType } from \"./utils/detectContentType\";\nimport { optimizeImage } from \"./sharp/optimizeImage\";\nimport { JPEG } from \"./constants\";\nimport { getMaxAge } from \"./utils/getMaxAge\";\nimport { ImageUpstream } from \"./types\";\n\nexport * from \"./fetch/fetchExternalImage\";\nexport * from \"./types\";\nexport * from \"./cache\";\n\nexport async function imageOptimizer(\n  imageUpstream: ImageUpstream,\n  params: {\n    quality: number;\n    width: number;\n    mimeType: string;\n  }\n): Promise<{\n  buffer: Buffer;\n  contentType: string;\n  maxAge: number;\n  error?: unknown;\n}> {\n  const { quality, width, mimeType } = params;\n  const { buffer: upstreamBuffer } = imageUpstream;\n  const maxAge = getMaxAge(imageUpstream.cacheControl);\n\n  const upstreamType =\n    imageUpstream.contentType?.toLowerCase().trim() ||\n    detectContentType(upstreamBuffer);\n\n  if (upstreamType) {\n    if (upstreamType.startsWith(\"image/svg\")) {\n      throw new Error(\n        '\"url\" parameter is valid but image type svg is not allowed'\n      );\n    }\n    /*    if (ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)) {\n      if (!opts.silent) {\n        Log.warnOnce(\n          `The requested resource \"${href}\" is an animated image so it will not be optimized. Consider adding the \"unoptimized\" property to the <Image>.`\n        );\n      }\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge,\n        etag: upstreamEtag,\n        upstreamEtag,\n      };\n    } */\n\n    /* if (VECTOR_TYPES.includes(upstreamType)) {\n      // We don't warn here because we already know that \"dangerouslyAllowSVG\"\n      // was enabled above, therefore the user explicitly opted in.\n      // If we add more VECTOR_TYPES besides SVG, perhaps we could warn for those.\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge,\n      };\n    } */\n\n    if (!upstreamType.startsWith(\"image/\") || upstreamType.includes(\",\")) {\n      throw new Error(\"The requested resource isn't a valid image.\");\n    }\n  }\n\n  let contentType: string;\n\n  if (mimeType) {\n    contentType = mimeType;\n  } else {\n    contentType = JPEG;\n  }\n\n  /*  const previouslyCachedImage = getPreviouslyCachedImageOrNull(\n    imageUpstream,\n    opts.previousCacheEntry\n  );\n  if (previouslyCachedImage) {\n    return {\n      buffer: previouslyCachedImage.buffer,\n      contentType,\n      maxAge: opts?.previousCacheEntry?.curRevalidate || maxAge,\n      etag: previouslyCachedImage.etag,\n      upstreamEtag: previouslyCachedImage.upstreamEtag,\n    };\n  }\n */\n  try {\n    let optimizedBuffer = await optimizeImage({\n      buffer: upstreamBuffer,\n      contentType,\n      quality,\n      width,\n    });\n    /* if (opts.isDev && width <= BLUR_IMG_SIZE && quality === BLUR_QUALITY) {\n      // During `next dev`, we don't want to generate blur placeholders with webpack\n      // because it can delay starting the dev server. Instead, `next-image-loader.js`\n      // will inline a special url to lazily generate the blur placeholder at request time.\n      const meta = await getImageSize(optimizedBuffer);\n      const blurOpts = {\n        blurWidth: meta.width,\n        blurHeight: meta.height,\n        blurDataURL: `data:${contentType};base64,${optimizedBuffer.toString(\n          \"base64\"\n        )}`,\n      };\n      optimizedBuffer = Buffer.from(unescape(getImageBlurSvg(blurOpts)));\n      contentType = \"image/svg+xml\";\n    } */\n    return {\n      buffer: optimizedBuffer,\n      contentType,\n      maxAge: Math.max(maxAge, 60),\n    };\n  } catch (error) {\n    if (upstreamType) {\n      // If we fail to optimize, fallback to the original image\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge: 60,\n        error,\n      };\n    } else {\n      throw new Error(\n        \"Unable to optimize image and unable to fallback to upstream image\"\n      );\n    }\n  }\n}\n","export const AVIF = \"image/avif\";\nexport const WEBP = \"image/webp\";\nexport const PNG = \"image/png\";\nexport const JPEG = \"image/jpeg\";\nexport const GIF = \"image/gif\";\nexport const SVG = \"image/svg+xml\";\nexport const ICO = \"image/x-icon\";\nexport const TIFF = \"image/tiff\";\nexport const BMP = \"image/bmp\";\n\nexport const CACHE_VERSION = 4;\nexport const ANIMATABLE_TYPES = [WEBP, PNG, GIF];\nexport const VECTOR_TYPES = [SVG];\nexport const BLUR_IMG_SIZE = 8; // should match `next-image-loader`\nexport const BLUR_QUALITY = 70; // should match `next-image-load\n","import { AVIF, BMP, GIF, ICO, JPEG, PNG, SVG, TIFF, WEBP } from \"../constants\";\n\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nexport function detectContentType(buffer: Buffer) {\n  if ([0xff, 0xd8, 0xff].every((b, i) => buffer[i] === b)) {\n    return JPEG;\n  }\n  if (\n    [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a].every(\n      (b, i) => buffer[i] === b\n    )\n  ) {\n    return PNG;\n  }\n  if ([0x47, 0x49, 0x46, 0x38].every((b, i) => buffer[i] === b)) {\n    return GIF;\n  }\n  if (\n    [0x52, 0x49, 0x46, 0x46, 0, 0, 0, 0, 0x57, 0x45, 0x42, 0x50].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return WEBP;\n  }\n  if ([0x3c, 0x3f, 0x78, 0x6d, 0x6c].every((b, i) => buffer[i] === b)) {\n    return SVG;\n  }\n  if ([0x3c, 0x73, 0x76, 0x67].every((b, i) => buffer[i] === b)) {\n    return SVG;\n  }\n  if (\n    [0, 0, 0, 0, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return AVIF;\n  }\n  if ([0x00, 0x00, 0x01, 0x00].every((b, i) => buffer[i] === b)) {\n    return ICO;\n  }\n  if ([0x49, 0x49, 0x2a, 0x00].every((b, i) => buffer[i] === b)) {\n    return TIFF;\n  }\n  if ([0x42, 0x4d].every((b, i) => buffer[i] === b)) {\n    return BMP;\n  }\n  return null;\n}\n","import sharp from \"sharp\";\n\ntype SharpNamespace = typeof sharp;\ntype Sharp = (\n  input?:\n    | Buffer\n    | ArrayBuffer\n    | Uint8Array\n    | Uint8ClampedArray\n    | Int8Array\n    | Uint16Array\n    | Int16Array\n    | Uint32Array\n    | Int32Array\n    | Float32Array\n    | Float64Array\n    | string,\n  options?: sharp.SharpOptions\n) => sharp.Sharp;\n\nlet _sharp: SharpNamespace;\nexport function getSharp(concurrency?: number | null | undefined): Sharp {\n  if (_sharp) {\n    return _sharp;\n  }\n  try {\n    _sharp = sharp;\n    if (_sharp && sharp.concurrency() > 1) {\n      // Reducing concurrency should reduce the memory usage too.\n      // We more aggressively reduce in dev but also reduce in prod.\n      // https://sharp.pixelplumbing.com/api-utility#concurrency\n      const divisor = process.env.NODE_ENV === \"development\" ? 4 : 2;\n      _sharp.concurrency(\n        concurrency ?? Math.floor(Math.max(_sharp.concurrency() / divisor, 1))\n      );\n    }\n  } catch (e: unknown) {\n    throw e;\n  }\n  return _sharp;\n}\n","import { AVIF, JPEG, PNG, WEBP } from \"../constants\";\nimport { getSharp } from \"./getSharp\";\n\nexport async function optimizeImage({\n  buffer,\n  contentType,\n  quality,\n  width,\n  height,\n  limitInputPixels,\n  sequentialRead,\n  timeoutInSeconds,\n}: {\n  buffer: Buffer;\n  contentType: string;\n  quality: number;\n  width: number;\n  height?: number;\n  limitInputPixels?: number;\n  sequentialRead?: boolean | null;\n  timeoutInSeconds?: number;\n}): Promise<Buffer> {\n  const _sharp = getSharp();\n\n  const transformer = _sharp(buffer, {\n    limitInputPixels,\n    sequentialRead: sequentialRead ?? undefined,\n  })\n    .timeout({\n      seconds: timeoutInSeconds ?? 7,\n    })\n    .rotate();\n\n  if (height) {\n    transformer.resize(width, height);\n  } else {\n    transformer.resize(width, undefined, {\n      withoutEnlargement: true,\n    });\n  }\n\n  if (contentType === AVIF) {\n    transformer.avif({\n      quality: Math.max(quality - 20, 1),\n      effort: 3,\n    });\n  } else if (contentType === WEBP) {\n    transformer.webp({ quality });\n  } else if (contentType === PNG) {\n    transformer.png({ quality });\n  } else if (contentType === JPEG) {\n    transformer.jpeg({ quality, mozjpeg: true });\n  }\n\n  const optimizedBuffer = await transformer.toBuffer();\n\n  return optimizedBuffer;\n}\n","export function parseCacheControl(\n  str: string | null | undefined\n): Map<string, string> {\n  const map = new Map<string, string>();\n  if (!str) {\n    return map;\n  }\n  for (let directive of str.split(\",\")) {\n    let [key, value] = directive.trim().split(\"=\", 2);\n    key = key.toLowerCase();\n    if (value) {\n      value = value.toLowerCase();\n    }\n    map.set(key, value);\n  }\n  return map;\n}\n","import { parseCacheControl } from \"./parseCacheControl\";\n\nexport function getMaxAge(str: string | null | undefined): number {\n  const map = parseCacheControl(str);\n  if (map) {\n    let age = map.get(\"s-maxage\") || map.get(\"max-age\") || \"\";\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1);\n    }\n    const n = parseInt(age, 10);\n    if (!isNaN(n)) {\n      return n;\n    }\n  }\n  return 0;\n}\n","import { ImageUpstream } from \"../types\";\n\nexport async function fetchExternalImage(href: string): Promise<ImageUpstream> {\n  const res = await fetch(href, {\n    signal: AbortSignal.timeout(7_000),\n  }).catch((err) => err as Error);\n\n  if (res instanceof Error) {\n    const err = res as Error;\n    if (err.name === \"TimeoutError\") {\n      throw new Error(\n        '\"url\" parameter is valid but upstream response timed out'\n      );\n    }\n    throw err;\n  }\n\n  if (!res.ok) {\n    throw new Error(\n      '\"url\" parameter is valid but upstream response is invalid'\n    );\n  }\n\n  const buffer = Buffer.from(await res.arrayBuffer());\n  const contentType = res.headers.get(\"Content-Type\");\n  const cacheControl = res.headers.get(\"Cache-Control\");\n  return { buffer, contentType, cacheControl };\n}\n","import { join } from \"node:path\";\nimport { BLUR_IMG_SIZE, CACHE_VERSION } from \"../constants\";\nimport { getHash } from \"../utils/getHash\";\nimport { getSupportedMimeType } from \"../utils/getSupportedMimeType\";\nimport { promises } from \"node:fs\";\n\nexport class ImageOptimizerCache {\n  private cacheDir: string;\n\n  static validateParams(\n    acceptHeader: string,\n    query: {\n      url: string;\n      w: string;\n      q: string;\n    },\n    isDev: boolean\n  ):\n    | {\n        quality: number;\n        width: number;\n        mimeType: string;\n        href: string;\n        sizes: number[];\n        isAbsolute: boolean;\n        isStatic: boolean;\n        minimumCacheTTL: number;\n      }\n    | { errorMessage: string } {\n    const imageData = {\n      deviceSizes: [],\n      imageSizes: [],\n      domains: [],\n      minimumCacheTTL: 60,\n      formats: [\"image/webp\"],\n    };\n    const {\n      deviceSizes = [],\n      imageSizes = [],\n      domains = [],\n      minimumCacheTTL = 60,\n      formats = [\"image/webp\"],\n    } = imageData;\n    const remotePatterns: any[] = [];\n    const localPatterns: any[] = [];\n    const { url, w, q } = query;\n    let href: string;\n\n    if (!url) {\n      return { errorMessage: '\"url\" parameter is required' };\n    } else if (Array.isArray(url)) {\n      return { errorMessage: '\"url\" parameter cannot be an array' };\n    }\n\n    if (url.length > 3072) {\n      return { errorMessage: '\"url\" parameter is too long' };\n    }\n\n    if (url.startsWith(\"//\")) {\n      return {\n        errorMessage: '\"url\" parameter cannot be a protocol-relative URL (//)',\n      };\n    }\n\n    let isAbsolute: boolean;\n\n    if (url.startsWith(\"/\")) {\n      href = url;\n      isAbsolute = false;\n      /* if (\n          /\\/_next\\/image($|\\/)/.test(\n            decodeURIComponent(parseUrl(url)?.pathname ?? \"\")\n          )\n        ) {\n          return {\n            errorMessage: '\"url\" parameter cannot be recursive',\n          };\n        }\n        if (!hasLocalMatch(localPatterns, url)) {\n          return { errorMessage: '\"url\" parameter is not allowed' };\n        } */\n    } else {\n      let hrefParsed: URL;\n\n      try {\n        hrefParsed = new URL(url);\n        href = hrefParsed.toString();\n        isAbsolute = true;\n      } catch (_error) {\n        return { errorMessage: '\"url\" parameter is invalid' };\n      }\n\n      if (![\"http:\", \"https:\"].includes(hrefParsed.protocol)) {\n        return { errorMessage: '\"url\" parameter is invalid' };\n      }\n\n      /* if (!hasRemoteMatch(domains, remotePatterns, hrefParsed)) {\n          return { errorMessage: '\"url\" parameter is not allowed' };\n        } */\n    }\n\n    if (!w) {\n      return { errorMessage: '\"w\" parameter (width) is required' };\n    } else if (Array.isArray(w)) {\n      return { errorMessage: '\"w\" parameter (width) cannot be an array' };\n    } else if (!/^[0-9]+$/.test(w)) {\n      return {\n        errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n      };\n    }\n\n    if (!q) {\n      return { errorMessage: '\"q\" parameter (quality) is required' };\n    } else if (Array.isArray(q)) {\n      return { errorMessage: '\"q\" parameter (quality) cannot be an array' };\n    } else if (!/^[0-9]+$/.test(q)) {\n      return {\n        errorMessage:\n          '\"q\" parameter (quality) must be an integer between 1 and 100',\n      };\n    }\n\n    const width = parseInt(w, 10);\n\n    if (width <= 0 || isNaN(width)) {\n      return {\n        errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n      };\n    }\n\n    const sizes: number[] = [...(deviceSizes || []), ...(imageSizes || [])];\n\n    const isValidSize =\n      sizes.includes(width) || (isDev && width <= BLUR_IMG_SIZE);\n\n    if (!isValidSize) {\n      return {\n        errorMessage: `\"w\" parameter (width) of ${width} is not allowed`,\n      };\n    }\n\n    const quality = parseInt(q, 10);\n\n    if (isNaN(quality) || quality < 1 || quality > 100) {\n      return {\n        errorMessage:\n          '\"q\" parameter (quality) must be an integer between 1 and 100',\n      };\n    }\n\n    const mimeType = getSupportedMimeType(formats || [], acceptHeader);\n\n    const isStatic = false;\n\n    return {\n      href,\n      sizes,\n      isAbsolute,\n      isStatic,\n      width,\n      quality,\n      mimeType,\n      minimumCacheTTL,\n    };\n  }\n\n  static getCacheKey({\n    href,\n    width,\n    quality,\n    mimeType,\n  }: {\n    href: string;\n    width: number;\n    quality: number;\n    mimeType: string;\n  }): string {\n    return getHash([CACHE_VERSION, href, width, quality, mimeType]);\n  }\n\n  constructor({ distDir }: { distDir: string }) {\n    this.cacheDir = join(distDir, \"cache\", \"images\");\n  }\n\n  async get(cacheKey: string): Promise<IncrementalCacheEntry | null> {\n    try {\n      const cacheDir = join(this.cacheDir, cacheKey);\n      const files = await promises.readdir(cacheDir);\n      const now = Date.now();\n\n      for (const file of files) {\n        const [maxAgeSt, expireAtSt, etag, upstreamEtag, extension] =\n          file.split(\".\", 5);\n        const buffer = await promises.readFile(join(cacheDir, file));\n        const expireAt = Number(expireAtSt);\n        const maxAge = Number(maxAgeSt);\n\n        return {\n          value: {\n            etag,\n            buffer,\n            extension,\n            upstreamEtag,\n          },\n          revalidateAfter: Math.max(maxAge) * 1000 + Date.now(),\n          curRevalidate: maxAge,\n          isStale: now > expireAt,\n          isFallback: false,\n        };\n      }\n    } catch (_) {\n      // failed to read from cache dir, treat as cache miss\n    }\n    return null;\n  }\n  async set(\n    cacheKey: string,\n    value: IncrementalCacheValue,\n    {\n      revalidate,\n    }: {\n      revalidate?: number | false;\n    }\n  ) {\n    if (typeof revalidate !== \"number\") {\n      throw new Error(\"invariant revalidate must be a number for image-cache\");\n    }\n    const expireAt = Math.max(revalidate) * 1000 + Date.now();\n\n    try {\n      await writeToCacheDir(\n        join(this.cacheDir, cacheKey),\n        value.extension,\n        revalidate,\n        expireAt,\n        value.buffer,\n        value.etag,\n        value.upstreamEtag\n      );\n    } catch (err) {\n      console.error(`Failed to write image to cache ${cacheKey}`, err);\n    }\n  }\n}\n\nasync function writeToCacheDir(\n  dir: string,\n  extension: string,\n  maxAge: number,\n  expireAt: number,\n  buffer: Buffer,\n  etag: string,\n  upstreamEtag: string\n) {\n  const filename = join(\n    dir,\n    `${maxAge}.${expireAt}.${etag}.${upstreamEtag}.${extension}`\n  );\n\n  await promises.rm(dir, { recursive: true, force: true }).catch(() => {});\n\n  await promises.mkdir(dir, { recursive: true });\n  await promises.writeFile(filename, buffer);\n}\n\ntype IncrementalCacheEntry = {\n  value: {\n    etag: string;\n    buffer: Buffer;\n    extension: string;\n    upstreamEtag: string;\n  };\n  revalidateAfter: number;\n  curRevalidate: number;\n  isStale: boolean;\n  isFallback: boolean;\n};\n\ntype IncrementalCacheValue = {\n  extension: string;\n  buffer: Buffer;\n  etag: string;\n  upstreamEtag: string;\n};\n","import { createHash } from \"node:crypto\";\n\nexport function getHash(items: (string | number | Buffer)[]) {\n    const hash = createHash(\"sha256\");\n    for (let item of items) {\n      if (typeof item === \"number\") hash.update(String(item));\n      else {\n        hash.update(item);\n      }\n    }\n    // See https://en.wikipedia.org/wiki/Base64#URL_applications\n    return hash.digest(\"base64url\");\n  }","export function getSupportedMimeType(options: string[], accept = \"\"): string {\n    const mimeType = /* mediaType(accept, options) */ \"image/webp\";\n    return accept.includes(mimeType) ? mimeType : \"\";\n  }\n  "],"mappings":"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","names":["sharp","_sharp"]}